import js.npm.Express;
import js.npm.express.*;
import js.Node;
import js.Node.*;
import js.npm.sequelize.Sequelize;
import js.node.Fs;

import yaml.Yaml;
import yaml.Parser;
import yaml.Renderer;
import yaml.util.ObjectMap;

import Conf;        // credentials and stuff
import Business;    // business logic goes and stays here

class Main {

  private static var initCache    = Node.require('sequelize-redis-cache');
  private static var redis        = Node.require('redis');
  private static var session      = Node.require('express-session');
  private static var vm           = Node.require('vm');
  private static var swaggerTools = Node.require('swagger-tools');
  private static var jsyaml       = Node.require('js-yaml');
  private static var passport     = Node.require('passport');


  private static var options = {
    controllers: './',
    useStubs: false
  };

  public static function getConf(conf : Dynamic, key : String, def : Dynamic) { 
	if (untyped __js__('conf[key] != undefined'))
            return untyped __js__('conf[key]')
	else return def ;
  }

  public static function main() {

    trace('#app : starting');

    var dn = Node.__dirname;
    var spec = Fs.readFileSync(dn+'/../app/api.yaml', 'utf8');

    // TODO : yaml parsing
    var data = Yaml.parse(spec); 
    trace(data.get('info'));


    //  CONFIGURATION
    var conf = new Conf('local');

    if (process.env.exists("ENV") && process.env['ENV'] == 'production')
      conf = new Conf('production');

    if (process.env.exists("ENV") && process.env['ENV'] == 'docker')
      conf = new Conf('docker', process.env);

    // MONITORING
    if (Reflect.field(conf, "ELK_SERVER")!=null){
	var config = {
    	    hosts: [getConf(conf,'ELK_SERVER','')],
    	    index: 'nodedata',
	    applicationName: getConf(conf,'APP_NAME','app')
    	}
 
	var appmetrics = require('appmetrics-elk').monitor(config);    
    }
    // REDIS CLIENT
    var redisClient = redis.createClient(conf.REDIS_PORT,conf.REDIS_HOST);

    // DATABASE
    var db = new Sequelize(conf.DB_NAME, conf.DB_USER, conf.DB_PASSWORD, 
      conf.DB_OPTIONS);

    /// CACHE(S)

    var coTTL = getConf(conf,'CACHE_OUT_TTL_DEFAULT',3600);

    var dbcacher = initCache(db, redisClient);
    var cacheo = Node.require('express-redis-cache')({
        client : redisClient,
        expire : coTTL,
        prefix : 'cacheout:'+getConf(conf,'APP_NAME','app')+':'
    });

    
    // SWAGGER
    var swaggerDoc = jsyaml.safeLoad(spec);

    swaggerTools.initializeMiddleware(swaggerDoc, function (middleware) {

    // EXPRESS
    var app : Application = new js.npm.Express();



    if (Reflect.field(conf, "SESSION_TTL")!=null){

    	  trace('#app : using standard session');
        var sessTTL = conf.SESSION_TTL;
        var redisStore = Node.require('connect-redis')(session);

        // SESSION
        app.use(new CookieParser('M4NU'));
        var ars= untyped __js__("new redisStore( { client: redisClient, ttl :  sessTTL})");
        app.use(
          session(
            {
              secret: 'orms_app',
              cookie: { maxAge: sessTTL },
              store: ars, 
              saveUninitialized: true,
              resave: true,
              rolling: true
            })
        );
      
    }

    // JWT

    if (Reflect.field(conf, "JWT_SECRET")!=null) {

          trace('#app : using standard session');
  	  var jwtSecret = getConf(conf,'JWT_SECRET','');
          var jwtTTL = getConf(conf,'conf.JWT_TTL','');

          var JWTRedisSession = require("jwt-redis-session");
  
          app.use(JWTRedisSession({
              client: redisClient,
              secret: jwtSecret,
              keyspace: "jwt:", 
              maxAge: jwtTTL,
              algorithm: "HS256",
              requestKey: "jwtSession",
              requestArg: "jwtToken"
          }));

          var handleRequest = function(req, res){

              var user : Dynamic= { id : 1 };

              req.jwtSession.user = haxe.Json.stringify(user); 

              // this will be attached to the JWT
              var claims = {
                  iss: "my application name",
                  aud: "myapplication.com"
              };

              req.jwtSession.create(claims, function(error, token){

                  res.json({ token: token });

              });

          };

          app.get('/jwt', untyped handleRequest);
            
          var handleRequest2 = function(req, res){

              console.log("Request JWT session data: ", 
                  req.jwtSession.id, 
                  req.jwtSession.claims, 
                  req.jwtSession.jwt
              );

              res.json(req.jwtSession.toJSON());

          };
          
          app.get('/jwt2', untyped handleRequest2);
            

      }


      // DEFAULT NO AUTH ON FRONT
      var websiteAuth = untyped function(req, res, next) {
          next(); 
      };

      // PASSPORT / GOOGLE TOKEN AUTH   
      if (Reflect.field(conf, "GOOGLE_CLIENT_ID")!=null) {

          trace('#app : using Passport auth');		
  	      var gClientId = getConf(conf,'GOOGLE_CLIENT_ID','');
            var gClientSecret = getConf(conf,'GOOGLE_CLIENT_SECRET','');
            var gCbUrl = getConf(conf,'GOOGLE_CALLBACK_URL','');

            var google_strategy = require('passport-google-oauth').OAuth2Strategy;

            app.use(passport.initialize());
              app.use(passport.session());

            passport.serializeUser(function(user, done) {
              done(null, user);
            });

            passport.deserializeUser(function(obj, done) {
              done(null, obj);
            });
        
            untyped __js__("Main.passport.use(new google_strategy({
             clientID: gClientId,
              clientSecret: gClientSecret,
              callbackURL: gCbUrl,
              scope: [ 'email', 'profile', 'https://www.googleapis.com/auth/userinfo.email' ]
            },
            function(accessToken, refreshToken, profile, done) {
              if (profile._json.domain == '{{userDomain}}') 
               return done(null,profile);
               else
               return done(new Error('something bad happened'));
             }
            ))");
        
            app.get('/',
            untyped function(req, res) {
              res.send('<a href="/google">login with google</>');
            });

            app.get('/google',
            passport.authenticate('google',{scope: [ 'email', 'profile', 'https://www.googleapis.com/auth/userinfo.email' ]}),
            untyped function(req, res){
            });

            app.get('/callback', 
            passport.authenticate('google', untyped { failureRedirect: '/logout' }),
            untyped function(req, res) {
              req.session.status = true;
              res.redirect('/site');
            });

            app.get('/logout',
            untyped function(req, res) {
                req.session.status = false;
                res.redirect('/');
            });

            // ACTIVATE FRONT AUTH
            websiteAuth = untyped function(req, res, next) {
            if (req.session.status== true) {
              next(); 
            } else {

              res.redirect("/"); 
            }
          };

      }

      app.use(BodyParser.json());
      app.use(BodyParser.urlencoded({extended: true}));


      // SWAGGER API DOC
      app.use('/doc', new js.npm.express.Static(dn+'/../node_modules/orms/doc'));
      app.use('/haxedoc', new js.npm.express.Static(dn+'/pages'));
      app.use('/api.yaml', new js.npm.express.Static(dn+'/../app/api.yaml'));
 
      // COMPANION WEBSITE
      app.use('/site', websiteAuth , new js.npm.express.Static(dn+'/../site'));

      // ROUTES SCAFOLDING FROM DOC 
      /**************************************************/
      // YOU CAN WRITE your BUSINESS CODE IN Business Class
      // ie : Business.get_method = function(req,res) {...}
      /**************************************************/
      // Hacks.. use summary to keep ttl and other stuff
      
      {{#operations}}{{#operation}}
      var apiOp = new ApiOperation("{{& path}}", "{{& summary}}");
      var args  = apiOp.getArgs();
      var extra = apiOp.getExtraParams();
      var path  = apiOp.getPath();
      var cacheExpire = function(req, res, next) {
        next();
      };
      if (args.ttl != '0') 
        cacheExpire = cacheo.route({ expire: args.ttl });
      app.{{httpMethod}}( conf.BASE_URL+path, untyped cacheExpire,
          function(req : Request, res : Response){ 
            untyped Business.{{httpMethod}}_{{operationId}}(db,req,res,dbcacher,cacheo,extra);
          }
      );
      {{/operation}}{{/operations}}

      app.use(middleware.swaggerMetadata());
      app.use(middleware.swaggerValidator());
    
      app.listen(conf.API_PORT);
      trace('api running on port '+conf.API_PORT);

    });
  }
}

class ApiOperation {

  var txtArgs   : String;
  var args      : Dynamic;
  var path      : String;
  var urlParams : Dynamic;
  var extraParams     : Dynamic; 

  public function new(pathParam, argsParam) {

    path = pathParam;
    txtArgs = argsParam;
    txtArgs   = StringTools.replace(txtArgs,"'",'"');
    args = haxe.Json.parse(txtArgs);
    
    var r = ~/\{([^}]+)\}/g;
    urlParams = [];
    r.map(path, function(r) {
      var match = r.matched(0);
      switch (match) {
          default: 
            var f = match;
            f   = StringTools.replace(f,'{',':');
            f   = StringTools.replace(f,'}','');
            urlParams.push(f); 
            return match;
      };
    });

    path   = StringTools.replace(path,'{',':');
    path   = StringTools.replace(path,'}','');

    // extraParams will hold all our query parameters
    extraParams = { 'url_params' : urlParams , 'ttl' : args.ttl, 'xttl' : args.xttl, 'cachekey' :  args.cachekey, 'xcachekey' : args.xcachekey };
 
  }

  public function getArgs() {
    return args;
  }

  public function getExtraParams() {
    return extraParams;
  }

  public function getPath() {
    return path;
  }

}
