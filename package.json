{
  "name": "orms",
  "version": "1.0.0",
  "description": "design-first haxe web api",
  "main": "",
  "private": false,
  "license": "CC BY-SA 3.0 FR",
  "scripts": {},
  "repository": {
    "type": "git",
    "url": "git+https://github.com/mebyz/orms.git"
  },
  "keywords": [
    "orms"
  ],
  "author": {
    "name": "emmanuel.botros@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/mebyz/orms/issues"
  },
  "homepage": "https://github.com/mebyz/orms#readme",
  "dependencies": {
  },
  "gitHead": "58fa74febae7db08faff7cb2bc2720de0fddbc57",
  "readme": "# ORMS : Design-First Haxe Web API Framework \n\n> ---\n\n> * We'll be happy to meet you during WWX2016, the WorldWide Haxe conference in Paris (27-30 May 2016) ! \n> \n![] (http://www.silexlabs.org/wp-content/uploads/2016/02/wwx2016-bandeau-blog-18fev2016-687x159.png)\n\n> * We are thrilled to give you the opportunity to attend to the first and live full presentation of ORMS (40 min talk)\n\n> ---\n\n- **ORMS Building blocks :**\n\n```\n\nHaxe, Nodejs, Mustache, Yaml, Bash scripts, \nHaxe/Node gems including thx.*, PromHx, Express, Sequelize, Tedious, \nCrypto, Dox, Open API (spec,codegen,doc ui,..), Redis, ELK, Passport.js, ...\n\n```\n\n![] (https://raw.githubusercontent.com/mebyz/orms/master/ORMS-stack-mini.png)\n\n- **PERFORMANCE :** ORMS heavily relies on **many cache layers**, and let you define your own **cache invalidation strategies**\n\n  - Custom output cache for each route based on your api specs\n\n  - Secure Cookie based Session / Auth token Redis store\n   \n  - Pro-active cascading cache invalidation strategies\n  \n  - Db caching (via Sequelize) : use cache to store entities and queries\n  \n  - Define your own caching strategies for fine tuning\n\n- **SECURITY :** ORMS offers you **multiple authentication strategies** activate them in your configuration file ./app/conf/[env].yaml \n\n  - JSON Web Tokens (JWT) : if you want to build RestFULL APIs or if you have to deal with cookie-less clients\n\n  - Standard but fast and secure sessions strategy if you're setting up a service targeting Web browsers supporting cookies\n\n  - ORMS also implements Passport.js (which includes 300+ more auth strategies) !\n\n- **MONITORING :** ORMS implements monitoring natively, with the support of the gorgious **ELK stack + appmetrics**. use ELK_SERVER parameter in your ./app/conf/[env].yaml file and you're good to go !\n\n- **DESIGN FIRST :** ORMS follows the **openapi** specification. creating and modifying your api is done using **yaml language**\n\n- **MOCK YOUR TESTS IN THE SPEC DESCRIPTION :** simply mock some test cases (a request and its response) in the **yaml specification** file  and let **mocha** do the magic !\n\n- **AUTOMATIC DOCGEN :** an **interactive documentation** is automatically generated from the spec file \n\n- **AUTOMATIC CODEGEN :** API server code (routing, server core...) is **automatically generated** from the spec file\n\n- **CORE / BUSINESS CODE LOGIC SEPARATION :** your business logic **is separated from** orms server core are during the whole life af your project.\n\n- **STRONGLY TYPED CODE :** Write your business logic using **Haxe language** (type checking helps the code to stay clean and secure). target is nodejs for now\n\n- **OPEN SOURCE, MULTIOS, FAST BOOTSTRAPPING STACK :** ORMS can be set up (within minutes), modified and deployed **anywhere nodejs can run** : Unix/Linux, Windows, OSx, ...\n\n- **MULTIDB :** ORMS uses **Sequelize** : connect to mssql, mysql, pgsql, sqlite,... databases\n\n- **PROMISES-FULL :** Use the great power of promises using a simple Haxe ( **Promhx, Thx.*,..** ) workflow\n\n- **DB PROMISES :** ORMS handles **parallel db querying strategies**\n\n- **CONTAINER READY :** ORMS comes with a **native docker container environment** for your app. You can now trully **deploy anywhere !**\n\n# BUILD YOUR API USING ORMS\n**remider: ORMS is meant to be used as a dependency !!**\n\n**STEP BY STEP :**\n\n**1 .Fork https://github.com/mebyz/orms-sample-app to bootstrap you own orms app !**\n \n2 . You'll need **Haxe** installed on your system\n\n3 . Design and implement your api : \n\n - Define your api spec in the **./app/api.yaml** file\n\n - Code your business logic in the **./app/Business/** folder\n\n - Use the **./app/conf/[env].yaml** file to set your configuration (db user/pass, ...)\n\n4 . you'll need a running database server\n\n5 . you'll need a running **redis server** ( locally : `redis-server` )\n \n**=> compile using :** `./build.sh`\n\n**- You can then simply run your api using :** `./run.sh`\n\n**- or deploy a local docker container and run your api from here :** `./docker.sh`\n\n# ORMS INSIGHTS : code\n\n**SAMPLE CODE : OPEN API YAML ROUTE DEFINITION**\n\n```yaml\npaths:\n  /cars:\n    get:\n      operationId: cars\n      tags:\n      - \"Stores\"\n      summary: \"{'ttl':3600,'xttl':3600,'cachekey':'','xcachekey':''}\"\n      description: \"The Cars List returns information about cars\"\n      parameters:\n      - name: \"AccessKeyId\"\n        in: \"header\"\n        description: \"Access Key Id\"\n        required: false\n        type: \"string\"\n      responses:\n        200:\n          description: \"An array of cars\"\n          schema:\n            $ref: \"#/definitions/Cars\"\n        default:\n          description: \"Unexpected error\"\n          schema:\n            $ref: \"#/definitions/Error\"\n```\n\n**YAML CONFIGURATION : example here : ./app/conf/local.yaml**\n\n```yaml\nAPP_NAME: orms_sample_app\nENV_NAME: local\n#ELK_SERVER: to be defined\n#JWT_SECRET: local_secret_key\n#JWT_TTL: 3600\nCACHE_OUT_TTL_DEFAULT: 60\n#GOOGLE_CLIENT_ID: to be defined\n#GOOGLE_CLIENT_SECRET: to be defined\n#GOOGLE_CALLBACK_URL: http://localhost:3000/callback\nREDIS_HOST: localhost\nREDIS_PORT: 6379\nDB_HOST:\nDB_USER:\nDB_PASSWORD:\nDB_NAME:\nDB_OPTIONS: \n  dialect: sqlite\n  storage: ../db.sqlite\n  pool: \n    max: 5\n    min: 0\n    idle: 10000\n  dialectOptions:\n    encrypt: true\n  logging: false\nSESSION_TTL: 3600\nBASE_URL: /api/v1\nAPI_PORT: 3000\n```\n\n**SAMPLE CODE : HAXE PROMISES**\n\n```\t\t\t\n    public static function firstPromise(/* some args here, such as \"myArg : Int\" */) : Promise</* return type here, such as \"String\"*/>{\n      var p = new Deferred<String>();\n        some.async.Method(/* some params */, function(err,data){\n          p.resolve(data);\n        });\n      return p.promise();\n    }\n  \n    public static function secondPromise(/* some args here, such as \"myArg : Int\" */) : Promise</* return type here, such as \"String\"*/>{\n      var p = new Deferred<String>();\n        some.async.OtherMethod(/* some params */, function(err,data){\n          p.resolve(data);\n        });\n      return p.promise();\n    }\n\n    public static function finalPromise(\tmyArg1 : /* return type of firstPromise */, \n\t\t\t\t\tmyArg2 : /* return type of secondPromise */\n\t\t\t\t   ) : Promise</* return type here, such as \"String\"*/> {\n      var p = new Deferred<String>();\n      \t // do something with the results\n        some.async.FinalMethod(myArg1, myArg2 , function(err,data){\n\t  // here is our final result\n          p.resolve(data);\n        });\n      return p.promise();\n    }\n\n    // NOW YOU CAN USE YOUR PROMISES AS FOLLOWS : \n\n    // TRIGGER YOUR FIRST PROMISE => try to fullfill 2 subpromises (parallel)\n    Promise.when(\t\t\t\n      firstPromise(/* some args for this first promise */), \n      secondPromise(/* some args for this second promise */)\n    )\n    .then(\n      // WHEN BOTH SUBPROMISES HAVE BEEN FULFILLED :\n      // TRIGGER 2ND PROMISE => gather fulfilled sub-promises results and process them\n      function(a,b) return finalPromise(a,b)\n    )\n    .then(function(b) {\n\t    trace(\"everything went ok. rainbow.\");\n    });\n```\n\n**SAMPLE CODE : PARALLEL QUERIES USING PROMISES**\n\n```\t\t\n     // PARALLEL CALL SOME QUERIES USING SEQUELIZE PROMISES\n      var SPromise = Sequelize.Promise;\n      SPromise.map([\n          sql1,\n          sql2\n      ], function runQuery(query) {\n          return db.query(query);\n      }).then(function(result) {\n      \t\t// result now contains data from sql1 AND sql2 execution\n          trace(result);\n      });\n```\t\t\n\n# End-to-End TESTS\n\n**REMINDER : TESTS (AND MOCK DATAS) ARE DEFINED IN YOUR PROJECT'S API.YAML FILE**\n\n=> For each route defined in the spec, you can/should add a `x-amples` key in wich you can write new tests.\n\n```yaml\npaths:\n  /users/me/status:\n    get:\n      ...\n      ...\n      x-amples:\n      - title: TEST1 - fail to auth user 1\n        description: \"fail to auth user\"\n        request: {}\n        response:\n          status: 401\n      - title: TEST2 - fail to auth user 2\n        description: \"fail to auth user\"\n        request: \n          headers: \n            Authorization: \"Basic bad_auth_hash_key\"\n        response:\n          status: 401\n      - title: TEST3 - auth user ok\n        description: \"auth user ok\"\n        request: \n          headers: \n            Authorization: \"Basic ZDSGOJGDFJKLGFJKSFLDGJLJGSFKLFDJGSLJFDGSLJ=\"\n        response:\n          status: 200\n          body: ''\n```\n\n**--- run tests locally:**\n\n1 . Change the host value in the api.yaml file to `localhost:3000` \n\n2 . You will need a running api (local)\n\n3 . Run the test suite using mocha **(run this from the project's root folder, NOT from the ./distrib/ folder !)** :\n\n`npm install`\n\n`mocha test.js`\n\n# DOCS\n\n- **api description** resides in your project's `./app/api.yaml` file\n\n- **api interactive doc** can be seen here : `http://[host]/doc`\n\n- **haxedoc** can be seen here : `http://[host]/haxedoc`\n",
  "readmeFilename": "README.md",
  "_id": "orms@1.0.0",
  "_shasum": "8acc408dd3e177aa81080037217fa0df27cbbb28",
  "_from": "mebyz/orms",
  "_resolved": "git://github.com/mebyz/orms.git#58fa74febae7db08faff7cb2bc2720de0fddbc57"
}
