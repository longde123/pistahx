<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>ORMS by mebyz</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">ORMS</h1>
      <h2 class="project-tagline">mebyz/orms : Fast, Haxe based, Design-First, Secure, Monitored, CI-Ready, Promise-Full Web API Framework</h2>
      <a href="https://github.com/mebyz/orms" class="btn">View on GitHub</a>
      <a href="https://github.com/mebyz/orms/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/mebyz/orms/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="orms-design-first-haxe-web-api-framework" class="anchor" href="#orms-design-first-haxe-web-api-framework" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ORMS: Design-First Haxe Web API Framework</h1>

<blockquote>
<hr>

<ul>
<li>We'll be happy to meet you during WWX2016, the WorldWide Haxe conference in Paris (27-30 May 2016) ! </li>
</ul>

<p><img src="http://www.silexlabs.org/wp-content/uploads/2016/02/wwx2016-bandeau-blog-18fev2016-687x159.png" alt=""></p>

<ul>
<li>We are thrilled to give you the opportunity to attend to the first and live full presentation of ORMS (40 min talk)</li>
</ul>

<hr>
</blockquote>

<ul>
<li><strong>ORMS Building blocks :</strong></li>
</ul>

<pre><code>
Haxe, Nodejs, Mustache, Yaml, Bash scripts, 
Haxe/Node gems including thx.*, PromHx, Express, Sequelize, Tedious, 
Crypto, Dox, Open API (spec,codegen,doc ui,..), Redis, ELK, Passport.js, ...

</code></pre>

<p><img src="https://raw.githubusercontent.com/mebyz/orms/master/ORMS-stack-mini.png" alt=""></p>

<ul>
<li>
<p><strong>PERFORMANCE : ORMS heavily relies on many cache layers, and let you define your own cache invalidation strategies.</strong></p>

<ul>
<li><p>Custom output cache for each route based on your api specs</p></li>
<li><p>Secure Cookie based Session / Auth token Redis store</p></li>
<li><p>Pro-active cascading cache invalidation strategies</p></li>
<li><p>Db caching (via Sequelize) : use cache to store entities and queries</p></li>
<li><p>Define your own caching strategies for fine tuning</p></li>
</ul>
</li>
<li>
<p><strong>SECURITY : ORMS offers you multiple authentication strategies. activation is done in your configuration file ./conf/Conf.hx :</strong> </p>

<ul>
<li><p>JSON Web Tokens (JWT) : if you want to build RestFULL APIs or if you have to deal with cookie-less clients</p></li>
<li><p>Standard but fast and secure sessions strategy if you're setting up a service targeting Web browsers supporting cookies</p></li>
<li><p>ORMS also implements Passport.js (which includes 300+ more auth strategies) !</p></li>
</ul>
</li>
<li><p><strong>MONITORING: ORMS implements monitoring natively, with the support of the gorgious ELK stack + appmetrics. use ELK_SERVER parameter in Conf.hx file and you're good to go !</strong></p></li>
<li><p><strong>DESIGN FIRST : with ORMS, your API specification can be easily changed using a simple language paradigm (yaml)</strong></p></li>
<li><p><strong>MOCK YOUR TESTS IN THE SPEC DESCRIPTION : simply mock some test cases (a request and its response) in the YAML spec and let mocha do the magic !</strong></p></li>
<li><p><strong>AUTOMATIC DOCGEN : an interactive documentation is automatically generated from the spec</strong></p></li>
<li><p><strong>AUTOMATIC CODEGEN : API server code (routing, server core...) is automatically generated from the spec</strong></p></li>
<li><p><strong>CORE / BUSINESS CODE LOGIC SEPARATION : Business logic is separated from the server core code</strong></p></li>
<li><p><strong>STRONGLY TYPED CODE : Write your business logic in Haxe Lang (type checking helps the code to stay clean and secure). target is nodejs for now</strong></p></li>
<li><p><strong>OPEN SOURCE, MULTIOS, FAST BOOTSTRAPPING STACK: ORMS can be set up (within minutes), modified and deployed anywhere nodejs can : Unix/Linux, Windows, OSx, ...</strong></p></li>
<li><p><strong>MULTIDB: ORMS uses Sequelize : connect to mssql, mysql, pgsql, sqlite,... databases</strong></p></li>
<li><p><strong>PROMISES-FULL : Use the great power of promises using a simple Haxe (Promhx, Thx.*) workflow</strong></p></li>
<li><p><strong>DB PROMISES: ORMS handles parallel db querying strategies</strong></p></li>
<li><p><strong>CONTAINER READY: ORMS gives you a native docker container environment for your app. You can now trully deploy anywhere !</strong></p></li>
</ul>

<h1>
<a id="build-your-api-using-orms" class="anchor" href="#build-your-api-using-orms" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>BUILD YOUR API USING ORMS</h1>

<p><strong>remider: ORMS is meant to be used as a dependency !!</strong></p>

<p><strong>STEP BY STEP :</strong></p>

<p><strong>1 .Fork <a href="https://github.com/mebyz/orms-sample-app">https://github.com/mebyz/orms-sample-app</a> to bootstrap you own orms app !</strong></p>

<p>2 . You'll need <strong>Haxe</strong> installed on your system</p>

<p>3 . Design and implement your api : </p>

<ul>
<li><p>Define your api spec in the <strong>./app/api.yaml</strong> file</p></li>
<li><p>Code your business logic in the <strong>./app/Business/</strong> folder</p></li>
<li><p>Use the <strong>./conf/Conf.hx</strong> file to set your configuration (db user/pass, ...)</p></li>
</ul>

<p>4 . you'll need a running database server</p>

<p>5 . you'll need a running <strong>redis server</strong> ( locally : <code>redis-server</code> )</p>

<p><strong>=&gt; NOW you can compile using :</strong> <code>./build.sh</code></p>

<p><strong>=&gt; now AFTER building the api :</strong></p>

<p><strong>=&gt; You can simply run your api using :</strong> <code>./run.sh</code></p>

<p><strong>=&gt; or deploy a local docker container and run your api from here :</strong> <code>./docker.sh</code></p>

<h1>
<a id="end-to-end-tests" class="anchor" href="#end-to-end-tests" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>End-to-End TESTS</h1>

<p><strong>REMINDER : TESTS (AND MOCK DATAS) ARE DEFINED IN YOUR PROJECT'S API.YAML FILE</strong></p>

<p>=&gt; For each route defined in the spec, you can/should add a <code>x-amples</code> key in wich you can write new tests.</p>

<div class="highlight highlight-source-yaml"><pre><span class="pl-s"><span class="pl-ent">paths:</span></span>
  <span class="pl-s"><span class="pl-ent">/users/me/status:</span></span>
    <span class="pl-s"><span class="pl-ent">get:</span></span>
      ...
      ...
      <span class="pl-s"><span class="pl-ent">x-amples:</span></span>
      <span class="pl-s">- <span class="pl-ent">title:</span> <span class="pl-s">TEST1 - fail to auth user 1</span></span>
        <span class="pl-s"><span class="pl-ent">description:</span> <span class="pl-s"><span class="pl-pds">"</span>fail to auth user<span class="pl-pds">"</span></span></span>
        <span class="pl-s"><span class="pl-ent">request:</span> <span class="pl-s">{}</span></span>
        <span class="pl-s"><span class="pl-ent">response:</span></span>
          <span class="pl-c1"><span class="pl-ent">status:</span> 401</span>
      <span class="pl-s">- <span class="pl-ent">title:</span> <span class="pl-s">TEST2 - fail to auth user 2</span></span>
        <span class="pl-s"><span class="pl-ent">description:</span> <span class="pl-s"><span class="pl-pds">"</span>fail to auth user<span class="pl-pds">"</span></span></span>
        <span class="pl-s"><span class="pl-ent">request:</span> </span>
          <span class="pl-s"><span class="pl-ent">headers:</span> </span>
            <span class="pl-s"><span class="pl-ent">Authorization:</span> <span class="pl-s"><span class="pl-pds">"</span>Basic bad_auth_hash_key<span class="pl-pds">"</span></span></span>
        <span class="pl-s"><span class="pl-ent">response:</span></span>
          <span class="pl-c1"><span class="pl-ent">status:</span> 401</span>
      <span class="pl-s">- <span class="pl-ent">title:</span> <span class="pl-s">TEST3 - auth user ok</span></span>
        <span class="pl-s"><span class="pl-ent">description:</span> <span class="pl-s"><span class="pl-pds">"</span>auth user ok<span class="pl-pds">"</span></span></span>
        <span class="pl-s"><span class="pl-ent">request:</span> </span>
          <span class="pl-s"><span class="pl-ent">headers:</span> </span>
            <span class="pl-s"><span class="pl-ent">Authorization:</span> <span class="pl-s"><span class="pl-pds">"</span>Basic ZDSGOJGDFJKLGFJKSFLDGJLJGSFKLFDJGSLJFDGSLJ=<span class="pl-pds">"</span></span></span>
        <span class="pl-s"><span class="pl-ent">response:</span></span>
          <span class="pl-c1"><span class="pl-ent">status:</span> 200</span>
          <span class="pl-s"><span class="pl-ent">body:</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span></span></pre></div>

<p><strong>--- run tests locally:</strong></p>

<p>1 . Change the host value in the api.yaml file to <code>localhost:3000</code> </p>

<p>2 . You will need a running api (local)</p>

<p>3 . Run the test suite using mocha <strong>(run this from the project's root folder, NOT from the ./distrib/ folder !)</strong> :</p>

<p><code>npm install</code></p>

<p><code>mocha test.js</code></p>

<h1>
<a id="orms-insights--code" class="anchor" href="#orms-insights--code" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ORMS INSIGHTS : code</h1>

<p><strong>SAMPLE CODE : OPEN API YAML ROUTE DEFINITION</strong></p>

<div class="highlight highlight-source-yaml"><pre><span class="pl-s"><span class="pl-ent">paths:</span></span>
  <span class="pl-s"><span class="pl-ent">/cars:</span></span>
    <span class="pl-s"><span class="pl-ent">get:</span></span>
      <span class="pl-s"><span class="pl-ent">operationId:</span> <span class="pl-s">cars</span></span>
      <span class="pl-s"><span class="pl-ent">tags:</span></span>
      <span class="pl-s">- <span class="pl-s"><span class="pl-pds">"</span>Stores<span class="pl-pds">"</span></span></span>
      <span class="pl-s"><span class="pl-ent">summary:</span> <span class="pl-s"><span class="pl-pds">"</span>{'ttl':3600,'xttl':3600,'cachekey':'','xcachekey':''}<span class="pl-pds">"</span></span></span>
      <span class="pl-s"><span class="pl-ent">description:</span> <span class="pl-s"><span class="pl-pds">"</span>The Cars List returns information about cars<span class="pl-pds">"</span></span></span>
      <span class="pl-s"><span class="pl-ent">parameters:</span></span>
      <span class="pl-s">- <span class="pl-ent">name:</span> <span class="pl-s"><span class="pl-pds">"</span>AccessKeyId<span class="pl-pds">"</span></span></span>
        <span class="pl-s"><span class="pl-ent">in:</span> <span class="pl-s"><span class="pl-pds">"</span>header<span class="pl-pds">"</span></span></span>
        <span class="pl-s"><span class="pl-ent">description:</span> <span class="pl-s"><span class="pl-pds">"</span>Access Key Id<span class="pl-pds">"</span></span></span>
        <span class="pl-s"><span class="pl-ent">required:</span> <span class="pl-s">false</span></span>
        <span class="pl-s"><span class="pl-ent">type:</span> <span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span></span>
      <span class="pl-s"><span class="pl-ent">responses:</span></span>
        <span class="pl-s"><span class="pl-ent">200:</span></span>
          <span class="pl-s"><span class="pl-ent">description:</span> <span class="pl-s"><span class="pl-pds">"</span>An array of cars<span class="pl-pds">"</span></span></span>
          <span class="pl-s"><span class="pl-ent">schema:</span></span>
            <span class="pl-s"><span class="pl-ent">$ref:</span> <span class="pl-s"><span class="pl-pds">"</span>#/definitions/Cars<span class="pl-pds">"</span></span></span>
        <span class="pl-s"><span class="pl-ent">default:</span></span>
          <span class="pl-s"><span class="pl-ent">description:</span> <span class="pl-s"><span class="pl-pds">"</span>Unexpected error<span class="pl-pds">"</span></span></span>
          <span class="pl-s"><span class="pl-ent">schema:</span></span>
            <span class="pl-s"><span class="pl-ent">$ref:</span> <span class="pl-s"><span class="pl-pds">"</span>#/definitions/Error<span class="pl-pds">"</span></span></span></pre></div>

<p><strong>SAMPLE CODE : HAXE PROMISES</strong></p>

<pre><code>    public static function firstPromise(/* some args here, such as "myArg : Int" */) : Promise&lt;/* return type here, such as "String"*/&gt;{
      var p = new Deferred&lt;String&gt;();
        some.async.Method(/* some params */, function(err,data){
          p.resolve(data);
        });
      return p.promise();
    }

    public static function secondPromise(/* some args here, such as "myArg : Int" */) : Promise&lt;/* return type here, such as "String"*/&gt;{
      var p = new Deferred&lt;String&gt;();
        some.async.OtherMethod(/* some params */, function(err,data){
          p.resolve(data);
        });
      return p.promise();
    }

    public static function finalPromise(    myArg1 : /* return type of firstPromise */, 
                    myArg2 : /* return type of secondPromise */
                   ) : Promise&lt;/* return type here, such as "String"*/&gt; {
      var p = new Deferred&lt;String&gt;();
         // do something with the results
        some.async.FinalMethod(myArg1, myArg2 , function(err,data){
      // here is our final result
          p.resolve(data);
        });
      return p.promise();
    }

    // NOW YOU CAN USE YOUR PROMISES AS FOLLOWS : 

    // TRIGGER YOUR FIRST PROMISE =&gt; try to fullfill 2 subpromises (parallel)
    Promise.when(           
      firstPromise(/* some args for this first promise */), 
      secondPromise(/* some args for this second promise */)
    )
    .then(
      // WHEN BOTH SUBPROMISES HAVE BEEN FULFILLED :
      // TRIGGER 2ND PROMISE =&gt; gather fulfilled sub-promises results and process them
      function(a,b) return finalPromise(a,b)
    )
    .then(function(b) {
        trace("everything went ok. rainbow.");
    });
</code></pre>

<p><strong>SAMPLE CODE : PARALLEL QUERIES USING PROMISES</strong></p>

<pre><code>     // PARALLEL CALL SOME QUERIES USING SEQUELIZE PROMISES
      var SPromise = Sequelize.Promise;
      SPromise.map([
          sql1,
          sql2
      ], function runQuery(query) {
          return db.query(query);
      }).then(function(result) {
            // result now contains data from sql1 AND sql2 execution
          trace(result);
      });
</code></pre>

<h1>
<a id="docs" class="anchor" href="#docs" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DOCS</h1>

<ul>
<li><p><strong>api description</strong> resides in your project's <code>./app/api.yaml</code> file</p></li>
<li><p><strong>api interactive doc</strong> can be seen here : <code>http://[host]/doc</code></p></li>
<li><p><strong>haxedoc</strong> can be seen here : <code>http://[host]/haxedoc</code></p></li>
</ul>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/mebyz/orms">ORMS</a> is maintained by <a href="https://github.com/mebyz">mebyz</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
