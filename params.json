{
  "name": "ORMS",
  "tagline": "ORMS : Fast, Haxe based, Design-First, Secure, Monitored, CI-Ready, Promise-Full Web API",
  "body": "# ORMS : Design-First Haxe Web API Framework\r\n\r\n> ---\r\n\r\n> * We'll be happy to meet you during WWX2016, the WorldWide Haxe conference in Paris (27-30 May 2016) ! \r\n> \r\n![] (http://www.silexlabs.org/wp-content/uploads/2016/02/wwx2016-bandeau-blog-18fev2016-687x159.png)\r\n\r\n> * We are thrilled to give you the opportunity to attend to the first and live full presentation of ORMS (40 min talk)\r\n\r\n> ---\r\n\r\n\r\n- **ORMS Building blocks :**\r\n\r\n```\r\n\r\nHaxe, Nodejs, Mustache, Yaml, Bash scripts, \r\nHaxe/Node gems including thx.*, PromHx, Express, Sequelize, Tedious, \r\nCrypto, Dox, Open API (spec,codegen,doc ui,..), Redis, ELK, Passport.js, ...\r\n\r\n```\r\n\r\n![] (https://raw.githubusercontent.com/mebyz/orms/master/ORMS-stack-mini.png)\r\n\r\n- **PERFORMANCE : ORMS heavily relies on it's multiple cache layers**\r\n\r\n  - Custom output cache for each route based on your api specs\r\n\r\n  - Secure Cookie based Session / Auth token Redis store\r\n   \r\n  - Pro-active cascading cache invalidation strategies\r\n  \r\n  - Db caching (via Sequelize) : use cache to store entities and queries\r\n  \r\n  - Define your own caching strategies for fine tuning\r\n\r\n- **SECURITY : ORMS offers you multiple authentication strategies, which you can easily activate from your configuration file ( ./your_orms_app/conf/Conf.hx ) :** \r\n\r\n  - JSON Web Tokens (JWT) : if you want to build RestFULL APIs or if you have to deal with cookie-less clients\r\n\r\n  - Standard but fast and secure sessions strategy if you're setting up a service targeting Web browsers supporting cookies\r\n\r\n  - ORMS also implements Passport.js (which includes 300+ more auth strategies) !\r\n\r\n- **MONITORING: ORMS offers you instantaneaous monitoring with the support of the gorgious ELK stack and Appmetrics library. Simply fill ELK_SERVER parameter in conf file and you're good to go !**\r\n\r\n- **DESIGN FIRST : with ORMS, your API description/spec can be easily changed using a simple language paradigm (yaml)**\r\n\r\n- **MOCK YOUR TESTS IN THE SPEC DESCRIPTION : simply mock some test cases (a request and its response) in the YAML spec and let mocha do the magic !**\r\n\r\n- **AUTOMATIC DOCGEN : an interactive documentation is automatically generated from the spec**\r\n\r\n- **AUTOMATIC CODEGEN : API server code (routing, server core...) is automatically generated from the spec**\r\n\r\n- **CODE LOGIC SEPARATION : Business logic is separated from the server core code**\r\n\r\n- **STRONGLY TYPED CODE : The business logic is written in Haxe (type checking helps the code to stay clean and secure), before being transpiled to nodejs code**\r\n\r\n- **OPEN SOURCE, MULTIOS, FAST BOOTSTRAPPING STACK: ORMS can be set up, modified and deployed  everywhere nodejs code can run. Unix/Linux, Windows, OSx, ...**\r\n\r\n- **MULTIDB: ORMS uses Sequlize, which alllows you to connect to mssql, mysql, pgsql, sqlite,... databases**\r\n\r\n- **PROMISES-FULL : Use the mighty power of Promises using a simple Haxe (Promhx) workflow :**\r\n\r\n- **DB PROMISES: SEQUELIZE too handles parallel db querying strategies :**\r\n\r\n- **CONTAINER READY: ORMS gives you a native docker container environment for your app. You're finally able deploy everywhere**\r\n\r\n# BUILD YOUR API USING ORMS\r\n**remider: orms is meant to be used as a dependency !!**\r\n\r\n**STEP BY STEP :**\r\n\r\n**1 .Fork https://github.com/mebyz/orms-sample-app to bootstrap you own orms app !**\r\n \r\n2 . You'll need **Haxe** installed on your system\r\n\r\n3 . Design and implement your api : \r\n\r\n - Define your api spec in the **./app/api.yaml** file\r\n\r\n - Code your business logic in the **./app/Business/** folder\r\n\r\n - Use the **./conf/Conf.hx** file to set your configuration (db user/pass, ...)\r\n\r\n4 . you'll need a running database server\r\n\r\n5 . you'll need a running **redis server** ( locally : `redis-server` )\r\n \r\n**=> NOW you can compile using :** `./build.sh`\r\n\r\n**=> now AFTER building the api :**\r\n\r\n**=> You can simply run your api using :** `./run.sh`\r\n\r\n**=> or deploy a local docker container and run your api from here :** `./docker.sh`\r\n\r\n# End-to-End TESTS\r\n\r\n**REMINDER : TESTS (AND MOCK DATAS) ARE DEFINED IN YOUR PROJECT'S API.YAML FILE**\r\n\r\n=> For each route defined in the spec, you can/should add a `x-amples` key in wich you can write new tests.\r\n\r\n```yaml\r\npaths:\r\n  /users/me/status:\r\n    get:\r\n      ...\r\n      ...\r\n      x-amples:\r\n      - title: TEST1 - fail to auth user 1\r\n        description: \"fail to auth user\"\r\n        request: {}\r\n        response:\r\n          status: 401\r\n      - title: TEST2 - fail to auth user 2\r\n        description: \"fail to auth user\"\r\n        request: \r\n          headers: \r\n            Authorization: \"Basic bad_auth_hash_key\"\r\n        response:\r\n          status: 401\r\n      - title: TEST3 - auth user ok\r\n        description: \"auth user ok\"\r\n        request: \r\n          headers: \r\n            Authorization: \"Basic ZDSGOJGDFJKLGFJKSFLDGJLJGSFKLFDJGSLJFDGSLJ=\"\r\n        response:\r\n          status: 200\r\n          body: ''\r\n```\r\n\r\n**--- run tests locally:**\r\n\r\n1 . Change the host value in the api.yaml file to `localhost:3000` \r\n\r\n2 . You will need a running api (local)\r\n\r\n3 . Run the test suite using mocha **(run this from the project's root folder, NOT from the ./distrib/ folder !)** :\r\n\r\n`npm install`\r\n\r\n`mocha test.js`\r\n\r\n# ORMS INSIGHTS : code\r\n\r\n**SAMPLE CODE : OPEN API YAML ROUTE DEFINITION**\r\n\r\n```yaml\r\npaths:\r\n  /cars:\r\n    get:\r\n      operationId: cars\r\n      tags:\r\n      - \"Stores\"\r\n      summary: \"{'ttl':3600,'xttl':3600,'cachekey':'','xcachekey':''}\"\r\n      description: \"The Cars List returns information about cars\"\r\n      parameters:\r\n      - name: \"AccessKeyId\"\r\n        in: \"header\"\r\n        description: \"Access Key Id\"\r\n        required: false\r\n        type: \"string\"\r\n      responses:\r\n        200:\r\n          description: \"An array of cars\"\r\n          schema:\r\n            $ref: \"#/definitions/Cars\"\r\n        default:\r\n          description: \"Unexpected error\"\r\n          schema:\r\n            $ref: \"#/definitions/Error\"\r\n```\r\n\r\n**SAMPLE CODE : HAXE PROMISES**\r\n\r\n```\t\t\t\r\n    public static function firstPromise(/* some args here, such as \"myArg : Int\" */) : Promise</* return type here, such as \"String\"*/>{\r\n      var p = new Deferred<String>();\r\n        some.async.Method(/* some params */, function(err,data){\r\n          p.resolve(data);\r\n        });\r\n      return p.promise();\r\n    }\r\n  \r\n    public static function secondPromise(/* some args here, such as \"myArg : Int\" */) : Promise</* return type here, such as \"String\"*/>{\r\n      var p = new Deferred<String>();\r\n        some.async.OtherMethod(/* some params */, function(err,data){\r\n          p.resolve(data);\r\n        });\r\n      return p.promise();\r\n    }\r\n\r\n    public static function finalPromise(\tmyArg1 : /* return type of firstPromise */, \r\n\t\t\t\t\tmyArg2 : /* return type of secondPromise */\r\n\t\t\t\t   ) : Promise</* return type here, such as \"String\"*/> {\r\n      var p = new Deferred<String>();\r\n      \t // do something with the results\r\n        some.async.FinalMethod(myArg1, myArg2 , function(err,data){\r\n\t  // here is our final result\r\n          p.resolve(data);\r\n        });\r\n      return p.promise();\r\n    }\r\n\r\n    // NOW YOU CAN USE YOUR PROMISES AS FOLLOWS : \r\n\r\n    // TRIGGER YOUR FIRST PROMISE => try to fullfill 2 subpromises (parallel)\r\n    Promise.when(\t\t\t\r\n      firstPromise(/* some args for this first promise */), \r\n      secondPromise(/* some args for this second promise */)\r\n    )\r\n    .then(\r\n      // WHEN BOTH SUBPROMISES HAVE BEEN FULFILLED :\r\n      // TRIGGER 2ND PROMISE => gather fulfilled sub-promises results and process them\r\n      function(a,b) return finalPromise(a,b)\r\n    )\r\n    .then(function(b) {\r\n\t    trace(\"everything went ok. rainbow.\");\r\n    });\r\n```\r\n\r\n**SAMPLE CODE : PARALLEL QUERIES USING PROMISES**\r\n\r\n```\t\t\r\n     // PARALLEL CALL SOME QUERIES USING SEQUELIZE PROMISES\r\n      var SPromise = Sequelize.Promise;\r\n      SPromise.map([\r\n          sql1,\r\n          sql2\r\n      ], function runQuery(query) {\r\n          return db.query(query);\r\n      }).then(function(result) {\r\n      \t\t// result now contains data from sql1 AND sql2 execution\r\n          trace(result);\r\n      });\r\n```\t\t\r\n\r\n# DOCS\r\n\r\n- **api description** resides in your project's `./app/api.yaml` file\r\n\r\n- **api interactive doc** can be seen here : `http://[host]/doc`\r\n\r\n- **haxedoc** can be seen here : `http://[host]/haxedoc`\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}