{
  "name": "pistahx.io",
  "tagline": "",
  "body": "# pistahx.io : Design-First Type-Safe Haxe Web API Framework \r\n\r\n* We'll be happy to meet you during WWX2016, the WorldWide Haxe conference in Paris (27-30 May 2016) ! \r\n* We are thrilled to give you the opportunity to attend to the first and live full presentation of pistahx (40 min talk)\r\n\r\n![] (http://www.silexlabs.org/wp-content/uploads/2016/02/wwx2016-bandeau-blog-18fev2016-687x159.png)\r\n\r\n\r\n# bootstrap a sample pistahx based web api\r\n\r\npistahx-app \r\n(sample Haxe api using pistahx, pistahx-db, pistahx-spec)\r\n\r\n\r\n### 1. BUILD LOCALLY ( demo app : mebyz/pistahx-app )\r\n\r\n\r\n```\r\ngit clone github.com:mebyz/pistahx-app\r\n\r\ncd pistax-app/\r\n\r\n./prepare.sh\r\n\r\ngulp build\r\n\r\n```\r\n\r\n### 2. RUN LOCALLY\r\n\r\n```\r\ngulp run\r\n\r\n```\r\n\r\n#OR\r\n\r\n### 1. BUILD FROM DOCKER\r\n\r\n```\r\ngit clone github.com:mebyz/pistahx-app\r\n\r\ncd pistax-app/\r\n\r\ndocker build -f Dockerfile.build -t pistahx/build .\r\n\r\ndocker run -d --name pistahx_build pistahx/build tail -f /dev/null\r\n\r\ndocker cp pistahx_build:/app/distrib/out ./distrib/out\r\n\r\n```\r\n=> your built app now resides in distrib/out\r\n\r\n### 2. RUN WITH DOCKER-COMPOSE\r\n\r\n```\r\ndocker-compose build\r\n\r\ndocker-compose up\r\n\r\n```\r\n\r\n>\r\n- You'll need **Haxe** installed on your system\r\n>\r\n- Design and implement  your api spec in the **./app/api.yaml** file\r\n>\r\n- Code your business logic in the **./app/Business/** folder\r\n>\r\n- Use the **./app/conf/[env].yaml** file to set your configuration (db user/pass, ...)\r\n>\r\n- you'll need a running **redis server**\r\n\r\n-\r\n\r\n# pistahx modules :\r\n>\r\n####- https://github.com/mebyz/pistahx.git (pistahx's core)\r\n>\r\n####- https://github.com/mebyz/pistahx-db.git (DB to Haxe typedefs generation lib)\r\n>\r\n####- https://github.com/mebyz/pistahx-spec.git (OpenAPI yaml to Haxe typedefs generation lib)\r\n>\r\n####- https://github.com/mebyz/pistahx-ui.git (Typescript Angular2 Bootstrap4 UI for pistahx apps)\r\n>\r\n####- https://github.com/mebyz/pistahx-app.git (pistahx demo api, use it to bootstrap your own api !)\r\n\r\n-\r\n\r\n# pistahx Building blocks :\r\n>![] (https://raw.githubusercontent.com/mebyz/pistahx/master/pistahx-stack-mini.png)\r\n\r\n-\r\n\r\n# pistahx promises:\r\n\r\n>- **PERFORMANCE :** pistahx heavily relies on **many cache layers**, and let you define your own **cache invalidation strategies**\r\n  - Custom output cache for each route based on your api specs\r\n  - Secure Cookie based Session / Auth token Redis store\r\n  - Pro-active cascading cache invalidation strategies\r\n  - Db caching (via Sequelize) : use cache to store entities and queries\r\n  - Define your own caching strategies for fine tuning\r\n\r\n-\r\n\r\n>- **SECURITY :** pistahx offers you **multiple authentication strategies** activate them in your configuration file ./app/conf/[env].yaml \r\n  - JSON Web Tokens (JWT) : if you want to build RestFULL APIs or if you have to deal with cookie-less clients\r\n  - Standard but fast and secure sessions strategy if you're setting up a service targeting Web browsers supporting cookies\r\n  - pistahx also implements Passport.js (which includes 300+ more auth strategies) !\r\n\r\n-\r\n\r\n>- **MONITORING :** \r\n  - pistahx implements monitoring natively, with the support of the gorgious **ELK stack + appmetrics**. use ELK_SERVER parameter in your ./app/conf/[env].yaml file and you're good to go !\r\n\r\n-\r\n\r\n>- **DESIGN FIRST :** \r\n  - pistahx follows the **openapi** specification. creating and modifying your api is done using **yaml language**\r\n\r\n-\r\n\r\n>- **MOCK YOUR TESTS IN THE SPEC DESCRIPTION :** \r\n  - simply mock some test cases (a request and its response) in the **yaml specification** file  and let **mocha** do the magic !\r\n\r\n-\r\n\r\n>- **AUTOMATIC DOCGEN :** \r\n  - an **interactive documentation** is automatically generated from the spec file \r\n\r\n-\r\n\r\n>- **AUTOMATIC CODEGEN :** \r\n  - API server code (routing, server core...) is **automatically generated** from the spec file\r\n\r\n-\r\n\r\n>- **CORE / BUSINESS CODE LOGIC SEPARATION :** \r\n  - your business logic **is separated from** pistahx server core during the whole life of your project.\r\n\r\n-\r\n\r\n>- **STRONGLY TYPED CODE :** \r\n  - Write your business logic using **Haxe language** (type checking helps the code to stay clean and secure). pistahx tranpiles your api to nodejs.\r\n\r\n-\r\n\r\n>- **OPEN SOURCE, MULTIOS, FAST BOOTSTRAPPING STACK :** \r\n  - pistahx can be set up (within minutes), modified and deployed **anywhere nodejs can run** : Unix/Linux, Windows, OSx, ...\r\n\r\n-\r\n\r\n>- **MULTIDB :** \r\n  -  pistahx uses **Sequelize** : connect to mssql, mysql, pgsql, sqlite,... databases\r\n\r\n-\r\n\r\n>- **PROMISES-FULL :** \r\n  -  Use the great power of promises using a simple Haxe ( **Promhx, Thx.*,..** ) workflow\r\n\r\n-\r\n\r\n>- **DB PROMISES :** \r\n  -  pistahx handles **parallel db querying strategies**\r\n\r\n-\r\n\r\n>- **CONTAINER READY :** \r\n  -  pistahx comes with a **native docker container environment** for your app. You can now trully **deploy anywhere !**\r\n \r\n# pistahx INSIGHTS : code\r\n\r\n**SAMPLE CODE : OPEN API YAML ROUTE DEFINITION**\r\n\r\n```yaml\r\npaths:\r\n  /employees:\r\n    get:\r\n      operationId: employees\r\n      tags:\r\n      - \"Employees\"\r\n      summary: \"{'ttl':3600,'xttl':3600,'cachekey':'','xcachekey':''}\"\r\n      description: \"/employees returns a list of employee\"\r\n      responses:\r\n        200:\r\n          description: \"An array of employees\"\r\n          schema:\r\n            $ref: \"#/definitions/Employees\"\r\n  /employee/{EmployeeId}:\r\n    get:\r\n      operationId: employee\r\n      tags:\r\n      - \"Employees\"\r\n      summary: \"{'ttl':3600,'xttl':3600,'cachekey':'','xcachekey':''}\"\r\n      description: \"/employee/{EmployeeId} returns an employee\"\r\n      parameters:\r\n      - name: \"EmployeeId\"\r\n        in: \"path\"\r\n        description: \"EmployeeId\"\r\n        required: true\r\n        type: \"integer\"\r\n      responses:\r\n        200:\r\n          description: \"An employee\"\r\n          schema:\r\n            $ref: \"#/definitions/Employee\"\r\n  /employee:\r\n    put:\r\n      operationId: employee\r\n      tags:\r\n      - \"Employees\"\r\n      summary: \"{'ttl':0,'xttl':0,'cachekey':'','xcachekey':''}\"\r\n      description: \"/employee saves an employee\"\r\n      x-cache-flush: \r\n      - \"/employees\"\r\n      parameters:\r\n      - name: \"employee\"\r\n        in: \"body\"\r\n        description: \"Employee to add\"\r\n        required: true\r\n        schema:\r\n          $ref: '#/definitions/Employee'\r\n      responses:\r\n        200:\r\n          description: \"200 is returned\"\r\n```\r\n\r\n**YAML CONFIGURATION : example here : ./app/conf/local.yaml**\r\n\r\n```yaml\r\nAPP_NAME: pistahx_app\r\nENV_NAME: local\r\n#ELK_SERVER: to be defined\r\n#JWT_SECRET: local_secret_key\r\n#JWT_TTL: 3600\r\nCACHE_OUT_TTL_DEFAULT: 60\r\n#GOOGLE_CLIENT_ID: to be defined\r\n#GOOGLE_CLIENT_SECRET: to be defined\r\n#GOOGLE_CALLBACK_URL: http://localhost:3000/callback\r\nREDIS_HOST: localhost\r\nREDIS_PORT: 6379\r\nDB_HOST:\r\nDB_USER:\r\nDB_PASSWORD:\r\nDB_NAME:\r\nDB_OPTIONS: \r\n  dialect: sqlite\r\n  storage: Chinook_Sqlite.sqlite\r\n  pool: \r\n    max: 5\r\n    min: 0\r\n    idle: 10000\r\n  dialectOptions:\r\n    encrypt: true\r\n  logging: true\r\nSESSION_TTL: 3600\r\nBASE_URL: /api/v1\r\nAPI_PORT: 3000\r\nAPI_ROUTE_STATUS: /users/me/status\r\n#API_CORS_ALLOWED:\r\n#  - \"http://localhost:9000\"\r\n#  - \"http://localhost:8080\"\r\n#  - \"http://localhost:3000\"\r\n#S3_ID: \"to be defined\"\r\n#S3_KEY: \"to be defined\"\r\n#S3_BUCKET: \"to be defined\"\r\n#S3_REGION: \"to be defined\"\r\n#S3_FOLDER: \"to be defined\"\r\n```\r\n\r\n**SAMPLE CODE : Sample GET Business method using pistahx-db generated typedefs, and pistahx-spec generated typedefs & mappers**\r\n```     \r\n\r\n  typedef DBEmployees = {\r\n    findAll : FindAllOptions -> Promise<Array<DB__Employee>>,\r\n    find : FindOptions -> Promise<DB__Employee>\r\n  }\r\n\r\n  @:publicFields\r\n  class DbRepos {\r\n\r\n    var dbEmployees : DBEmployees;\r\n\r\n    function new(db : Sequelize) {\r\n      dbEmployees = db.import_(\"models/Employee.js\");\r\n      untyped dbAlbums.belongsTo(dbArtist, {foreignKey: 'ArtistId'});\r\n    }\r\n\r\n  }\r\n\r\n...\r\n...\r\n\r\n  public static function get_employees(db : Sequelize,req : ClientRequest, res : ServerResponse, dbcacher : Dynamic,outputcacher : Dynamic, extra : Dynamic) : Promise<Array<Employee>> {    \r\n\r\n    var dbr = new DbRepos(db);\r\n\r\n    return\r\n      dbr.dbEmployees.findAll({\r\n        limit : 5\r\n      }).then(function (dbEmployeesRes) {\r\n        return dbEmployeesRes.map(EmployeeMapper.dbEmployeeToEmployee); \r\n      });\r\n\r\n  }\r\n\r\n  public static function get_employee(db : Sequelize,req : ClientRequest, res : ServerResponse, dbcacher : Dynamic,outputcacher : Dynamic, extra : Dynamic) : Promise<Employee> {\r\n  \r\n    var dbr = new DbRepos(db);\r\n\r\n    return\r\n      dbr.dbEmployees.find({\r\n         where: [ { 'EmployeeId' : untyped req.params.EmployeeId } ]\r\n      }).then(function (dbEmployeeRes) {\r\n        return EmployeeMapper.dbEmployeeToEmployee(dbEmployeeRes);\r\n      });\r\n  }\r\n\r\n\r\n```     \r\n\r\n**SAMPLE CODE : HAXE PROMISES**\r\n\r\n```\t\t\t\r\n    public static function firstPromise(/* some args here, such as \"myArg : Int\" */) : Promise</* return type here, such as \"String\"*/>{\r\n      var p = new Deferred<String>();\r\n        some.async.Method(/* some params */, function(err,data){\r\n          p.resolve(data);\r\n        });\r\n      return p.promise();\r\n    }\r\n  \r\n    public static function secondPromise(/* some args here, such as \"myArg : Int\" */) : Promise</* return type here, such as \"String\"*/>{\r\n      var p = new Deferred<String>();\r\n        some.async.OtherMethod(/* some params */, function(err,data){\r\n          p.resolve(data);\r\n        });\r\n      return p.promise();\r\n    }\r\n\r\n    public static function finalPromise(\tmyArg1 : /* return type of firstPromise */, \r\n\t\t\t\t\tmyArg2 : /* return type of secondPromise */\r\n\t\t\t\t   ) : Promise</* return type here, such as \"String\"*/> {\r\n      var p = new Deferred<String>();\r\n      \t // do something with the results\r\n        some.async.FinalMethod(myArg1, myArg2 , function(err,data){\r\n\t  // here is our final result\r\n          p.resolve(data);\r\n        });\r\n      return p.promise();\r\n    }\r\n\r\n    // NOW YOU CAN USE YOUR PROMISES AS FOLLOWS : \r\n\r\n    // TRIGGER YOUR FIRST PROMISE => try to fullfill 2 subpromises (parallel)\r\n    Promise.when(\t\t\t\r\n      firstPromise(/* some args for this first promise */), \r\n      secondPromise(/* some args for this second promise */)\r\n    )\r\n    .then(\r\n      // WHEN BOTH SUBPROMISES HAVE BEEN FULFILLED :\r\n      // TRIGGER 2ND PROMISE => gather fulfilled sub-promises results and process them\r\n      function(a,b) return finalPromise(a,b)\r\n    )\r\n    .then(function(b) {\r\n\t    trace(\"everything went ok. rainbow.\");\r\n    });\r\n```\r\n\r\n**SAMPLE CODE : PARALLEL QUERIES USING PROMISES**\r\n\r\n```\t\t\r\n     // PARALLEL CALL SOME QUERIES USING SEQUELIZE PROMISES\r\n      var SPromise = Sequelize.Promise;\r\n      SPromise.map([\r\n          sql1,\r\n          sql2\r\n      ], function runQuery(query) {\r\n          return db.query(query);\r\n      }).then(function(result) {\r\n      \t\t// result now contains data from sql1 AND sql2 execution\r\n          trace(result);\r\n      });\r\n```\t\t\r\n\r\n# End-to-End TESTS\r\n\r\n**REMINDER : TESTS (AND MOCK DATAS) ARE DEFINED IN YOUR PROJECT'S API.YAML FILE**\r\n\r\n=> For each route defined in the spec, you can/should add a `x-amples` key in wich you can write new tests.\r\n\r\n```yaml\r\npaths:\r\n  /users/me/status:\r\n    get:\r\n      ...\r\n      ...\r\n      x-amples:\r\n      - title: TEST1 - fail to auth user 1\r\n        description: \"fail to auth user\"\r\n        request: {}\r\n        response:\r\n          status: 401\r\n      - title: TEST2 - fail to auth user 2\r\n        description: \"fail to auth user\"\r\n        request: \r\n          headers: \r\n            Authorization: \"Basic bad_auth_hash_key\"\r\n        response:\r\n          status: 401\r\n      - title: TEST3 - auth user ok\r\n        description: \"auth user ok\"\r\n        request: \r\n          headers: \r\n            Authorization: \"Basic ZDSGOJGDFJKLGFJKSFLDGJLJGSFKLFDJGSLJFDGSLJ=\"\r\n        response:\r\n          status: 200\r\n          body: ''\r\n```\r\n\r\n**--- run tests locally:**\r\n\r\n1 . Change the host value in the api.yaml file to `localhost:3000` \r\n\r\n2 . You will need a running api (local)\r\n\r\n3 . Run the test suite using mocha **(run this from the project's root folder, NOT from the ./distrib/ folder !)** :\r\n\r\n`mocha test.js`\r\n\r\n# DOCS\r\n\r\n- **api description** resides in your project's `./app/api.yaml` file\r\n\r\n- **api interactive doc** can be seen here : `http://[host]/doc`\r\n\r\n- **haxedoc** can be seen here : `http://[host]/haxedoc`\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}